"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreasuryContract = void 0;
const ton_core_1 = require("ton-core");
const ton_crypto_1 = require("ton-crypto");
const DictionaryMessageValue = {
    serialize(src, builder) {
        builder.storeUint(src.sendMode, 8);
        builder.storeRef((0, ton_core_1.beginCell)().store((0, ton_core_1.storeMessageRelaxed)(src.message)));
    },
    parse(src) {
        let sendMode = src.loadUint(8);
        let message = (0, ton_core_1.loadMessageRelaxed)(src.loadRef().beginParse());
        return { sendMode, message };
    },
};
function senderArgsToMessageRelaxed(args) {
    return (0, ton_core_1.internal)({
        to: args.to,
        value: args.value,
        init: args.init,
        body: args.body,
        bounce: args.bounce
    });
}
class TreasuryContract {
    static create(workchain, keypair) {
        return new TreasuryContract(workchain, keypair);
    }
    constructor(workchain, keypair) {
        this.seqno = 0;
        const data = (0, ton_core_1.beginCell)()
            .storeUint(0, 32) // Seqno
            .storeUint(698983191, 32) // Wallet Id
            .storeBuffer(keypair.publicKey)
            .endCell();
        this.init = { code: TreasuryContract.code, data };
        this.address = (0, ton_core_1.contractAddress)(workchain, this.init);
        this.keypair = keypair;
    }
    async sendMessages(provider, messages, sendMode) {
        let transfer = this.createTransfer({
            seqno: this.seqno++,
            sendMode: sendMode,
            messages: messages
        });
        await provider.external(transfer);
    }
    async send(provider, args) {
        await this.sendMessages(provider, [senderArgsToMessageRelaxed(args)], args.sendMode ?? undefined);
    }
    getSender(provider) {
        return {
            address: this.address,
            send: async (args) => {
                let transfer = this.createTransfer({
                    seqno: this.seqno++,
                    sendMode: args.sendMode ?? undefined,
                    messages: [senderArgsToMessageRelaxed(args)]
                });
                await provider.external(transfer);
            }
        };
    }
    async getBalance(provider) {
        return (await provider.getState()).balance;
    }
    /**
     * Create signed transfer
     */
    createTransfer(args) {
        // Resolve send mode
        let sendMode = ton_core_1.SendMode.PAY_GAS_SEPARATELY;
        if (args.sendMode !== null && args.sendMode !== undefined) {
            sendMode = args.sendMode;
        }
        // Resolve messages
        if (args.messages.length > 255) {
            throw new Error('Maximum number of messages is 255');
        }
        let messages = ton_core_1.Dictionary.empty(ton_core_1.Dictionary.Keys.Int(16), DictionaryMessageValue);
        let index = 0;
        for (let m of args.messages) {
            messages.set(index++, { sendMode, message: m });
        }
        // Create message
        let signingMessage = (0, ton_core_1.beginCell)()
            .storeUint(698983191, 32) // Wallet Id
            .storeUint(4294967295, 32) // Timeout
            .storeUint(args.seqno, 32) // Seqno
            .storeDict(messages);
        // Sign message
        let signature = (0, ton_crypto_1.sign)(signingMessage.endCell().hash(), this.keypair.secretKey);
        // Body
        const body = (0, ton_core_1.beginCell)()
            .storeBuffer(signature)
            .storeBuilder(signingMessage)
            .endCell();
        return body;
    }
}
exports.TreasuryContract = TreasuryContract;
TreasuryContract.code = ton_core_1.Cell.fromBase64('te6ccgEBCAEAlwABFP8A9KQT9LzyyAsBAgEgAgMCAUgEBQC48oMI1xgg0x/TH9MfAvgju/Jj7UTQ0x/TH9P/0VEyuvKhUUS68qIE+QFUEFX5EPKj9ATR+AB/jhYhgBD0eG+lIJgC0wfUMAH7AJEy4gGz5lsBpMjLH8sfy//J7VQABNAwAgFIBgcAF7s5ztRNDTPzHXC/+AARuMl+1E0NcLH4');
